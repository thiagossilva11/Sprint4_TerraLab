# -*- coding: utf-8 -*-
"""TerraLab Python/Pandas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16ql9B9k3pc01IlME9NSq6MBQ5Z75St74
"""

import pandas as pd

data = pd.read_csv("/content/GasPricesInBrazil.csv")

data = pd.read_csv('/content/GasPricesInBrazil.csv', sep=';')

data

data.head()

data.head(10)

data.info()

"""# Data Frame
Todo dataset carregado (dados estruturados é um Data Frame
"""

type(data)

data.shape

print(f"O DataFrame possui {data.shape[0]} linhas/observações/registros e {data.shape[1]} colunas/variáveis")

"""# Criando um Data Frame"""

personagens_df = pd.DataFrame({
    'nome': ['Luke Skywalker', 'Yoda', 'Palpatine'],
    'idade': [16, 1000, 70],
    'peso': [70.5, 15.2, 60.1],
    'eh jedi': [True, True, False]  # o nome das colunas podem ter espaços
})

personagens_df

personagens_df.info()

"""# Renomeando as colunas de um DataFrame"""

personagens_df.columns

type(personagens_df.columns)

list(personagens_df.columns)

personagens_df

personagens_df.rename(columns= {"nome": "Nome Completo",
"idade": "Idade"}) #Criei uma copia

personagens_df

#Agora vou realmente renomear meu dataframe
personagens_df.rename(columns= {"nome": "Nome Completo",
"idade": "Idade"}, inplace=True)

personagens_df

#Agora renomear todas as colunas de uma vez

personagens_df.columns

personagens_df.columns = ['Nome Completo', 'Idade', 'Peso', 'Eh Jedi']

personagens_df

"""# Series"""

data.head()

#Selecionando uma coluna inteira
data["ESTADO"]

#Selecionando uma coluna inteira
#esta forma de acesso, só funciona para colunas co nomes sem espaços, acentos,etc (caracteres inválidos)
data.ESTADO

type(data["ESTADO"])

#Localizando dados de indexada no índice , (todos os valores que possuem como primary key 1)
data.iloc[1]

"""# Criando uma Series"""

pd.Series([5.5,6.0,9.5])

pd.Series([5.5,6.0,9.5], index = ["prova 1", "prova 2", "projeto"] , name = "Notas do Luke Skywalker")

"""#Atribuindo Dados

"""

#Atribuindo constantes
data.head()

produto_view = data["PRODUTO"] #A series retornada referente a coluna, NÃO É UMA CÓPIA, mas uma referência a coluna dataframme
produto_view

produto_copy_bkp = data["PRODUTO"].copy() #retorna uma  cópia da coluna "Produto"
produto_copy_bkp

data["PRODUTO"] = "Combustível" # Atribuindo o valor constante "Combustível" para cada linha do dateframe

data.head()

produto_view

produto_copy_bkp

"""#ATRIBUINDO LISTA OU SERIES"""

data.shape

nrows, ncols = data.shape
nrows,ncols

novos_produtos = [f"Produto {i}" for i in range(nrows)]
len(novos_produtos)

#A quantidade de elementos na lista "novos_produtos" é igual ao número de linhas do dataframe
data["PRODUTO"] = novos_produtos
data

print(produto_view)
produto_copy_bkp

#voltando para  os produtos originais
data["PRODUTO"] = produto_copy_bkp #Produto cpy agora é uma series
data

"""#CRIANDO NOVAS  COLUNAS"""

#criando uma coluna a partir de um valor constante/default
#todas as linhas terão o mesmo valor para esta nova coluna
data["coluna sem noçao"] = "Default"
data.head()

data["coluna a partir de lista"] = range(data.shape[0])
data

#não funciona pq a quantidade de linhas do dataframe, com o tamanho que estou criando, não batem e por isso vai dar erro.
#data["Não funciona"] = [1,2,3]

data.head()

data["PREÇO MÉDIO REVENDA"] = pd.to_numeric(data["PREÇO MÉDIO REVENDA"], errors='coerce') #Transformando a coluna para valor númérico

data["PREÇO MÉDIA DE REVENDA (EM DÓLARES)"] = data["PREÇO MÉDIO REVENDA"] * 6.0
data

"""#Índices"""

data.index

pesquisa_de_satisfacao = pd.DataFrame({
    'bom': [50, 21, 100],
    'ruim': [131, 2, 30],
    'pessimo': [30, 20, 1]},
index=['XboxOne', 'Playstation4', 'Switch'])
pesquisa_de_satisfacao.head()

pesquisa_de_satisfacao.index

"""#Selecionando uma ou mais amostras (Indexação)

"""

data.head()

#Usar ILOC: seleciona elementos do DataFrame, baseado em seu índice(número) row-first,column-second
#Quero pegar apenas uma amostra do dataframe
data.iloc[1]

#Selecionando múltiplas linhas | índice de 0 a 5 (incluso)
data.iloc[0:6]

#selecionando as linhas de índice de 10 a 15 (incluso)
data.iloc[10:16]

#selecionando as linhas/ observações de índice 1, 5 , 10, 15
data.iloc[[1,5,10,15]]

#Podemos também fazer essas seleções fora de ordem
data.iloc[[15,10,5,1]]

#retornar o valor da linha de índice 1, coluna 4 ("ESTADO")
data.iloc[1,3]

"""#Seleção Baseada em Rótulos"""

pesquisa_de_satisfacao

#retorna uma linha de índice 0 (implícito)
pesquisa_de_satisfacao.iloc[0]

#retorna o valor da linha de índice 0 (implícito) e coluna de índice 1 => usando o iloc
pesquisa_de_satisfacao.iloc[0,1]

#retorna a linha cujo rótulo do índice é XBOX
pesquisa_de_satisfacao.loc["XboxOne"] #retorna a linha de índice "XboxOne"

#Não funciona =>  iloc tentando acessar índices com rótulos
#pesquisa_de_satisfacao.iloc["XboxOne"]

#Não funciona => loc , tentando acessar índices rotulados com números
#pesquisa_de_satisfacao.iloc["XboxOne"]

pesquisa_de_satisfacao.loc["Playstation4","ruim"] #retorna o valor da linha de índice "Playstation4" e coluna de índice "ruim"

pesquisa_de_satisfacao.loc[["XboxOne","Switch"]] #retorna o valor da linha de índice "XboxOne" e coluna de índice "Switch"

#retorna todas as linhas e apenas as colunas com rótulos "bom" e "péssimo"
pesquisa_de_satisfacao.loc[:,["bom","pessimo"]]

"""Obervação: Índices números por default, possuem rótulos que correspondem aos seus valores númericos"""

data.head()

"""#Selecionando uma ou mais colunas (atributos)"""

data.head()

#retornando a coluna/atributo "Estado"
data["ESTADO"]

data.ESTADO

data.loc[:,"ESTADO",]

#a forma de acesso de colunas por .Nome da COluna só funciona se o nome não possuir caracteres inválidos (' ' , acentos, cedilha, etc..)

#para colunas cujos rótulos possuem caracteres inválidos,
#apenas a seleção via string é válida

#Selecionando múltiplas colunas
data[["PRODUTO", "ESTADO", "REGIÃO"]]

"""#Removendo um atributo (Coluna) do Data Frame"""

data.head()

#deleta/remove in place (ou seja, no próprio Data Frame)
#Vamos deletar as colunas fictícias criadas
del data["coluna sem noçao"]
del data["coluna a partir de lista"]
del data["PREÇO MÉDIA DE REVENDA (EM DÓLARES)"]

data.head()

"""#Salvando um Data Frame"""

data.to_csv("/content/GasPricesInBrazil_2004-2019_preprocessado.csv", index=False, sep = ";")

"""#Seleção Condicional: Filtrando amostras"""

data = pd.read_csv("/content/GasPricesInBrazil_2004-2019_preprocessado.csv", sep=';')
data.head()

data["ESTADO"].unique() #Mostra todos os valores distintos presentes nas linhas da coluna

"""Selecionando apenas os preços dos Postos em São Paulo"""

#Alternativa 1 :
data["ESTADO"] == "SÃO PAULO"

#salvando essa series de booleans em uma variável
selecao = data["ESTADO"] == "SAO PAULO"

type(selecao)

selecao.shape

data.shape

data[selecao]

#Alternativa 2: Utilizando o método Query
#query filtra linhas de um DataFrame baseado em uma query  (pergunta)
data.query("ESTADO == 'SAO PAULO'")

#Boa prática: Salvar os filtros criados em variáveis:
postos_sp = data.query("ESTADO == 'SAO PAULO'")
postos_sp

type(postos_sp)

postos_sp.shape

postos_sp.head()

#Resetando os Índices:
postos_sp.reset_index(inplace=True, drop=True)
postos_sp

#Alternativa muito comum
postos_sp = data.query("ESTADO == 'SAO PAULO'").reset_index(drop=True)
postos_sp

"""#Selecionando registros de postos do Rio de Janeiro com preços acima de 2 reais"""

data["ESTADO"].unique()

postos_rj = data.query("ESTADO == 'RIO DE JANEIRO'")
selecao = (data["ESTADO"] == "RIO DE JANEIRO") & (data["PREÇO MÉDIO REVENDA"] > 2)
selecao

data[selecao]

#Aprofundando ainda mais
#Fazendo filtragem com muitos condicionais afim de aumentar a performance do Pandass
selecao_1 = data["ESTADO"] == "RIO DE JANEIRO"
selecao_2 = postos_rj["PREÇO MÉDIO REVENDA"] > 2
postos_rj_preco_maior_que_2 = postos_rj[selecao_2]
postos_rj_preco_maior_que_2

"""#Selecionando registros de postos de São Paulo ou Rio de Janeiro com Gasolina Comum acima de 2 reais."""

#Podemos fazaer a solução do jeito mais lento, percorrendo o DataFrame inteiro múltiplas vezes:
data.head()



import pandas as pd
data = pd.read_csv("/content/GasPricesInBrazil.csv", sep=';')

# Convert "PREÇO MÉDIO REVENDA" column to numeric type, handling errors
data["PREÇO MÉDIO REVENDA"] = pd.to_numeric(data["PREÇO MÉDIO REVENDA"], errors='coerce')

selecao_1 = (data["ESTADO"] == "SAO PAULO") | (data["ESTADO"] == "RIO DE JANEIRO")
selecao_2 = (data["PRODUTO"] == "GASOLINA COMUM")
selecao_3 = (data["PREÇO MÉDIO REVENDA"] > 2)  # Now this comparison should work
selecao_final = selecao_1 & selecao_2 & selecao_3

# Use the boolean mask to filter the DataFrame 'data'
data_filtrada = data[selecao_final]

print(data_filtrada["ESTADO"].unique() )
print(data_filtrada["PRODUTO"].unique())

#Alternativamente também podemos fazer:
selecao_1 = (data["ESTADO"] == "SAO PAULO") | (data["ESTADO"] == "RIO DE JANEIRO")
postos_sp_rj = data[selecao_1]

#Apenas registros dos postos dos estados de RJ e SP
postos_sp_rj

selecao_2 = (postos_sp_rj["PRODUTO"] == "GASOLINA COMUM")
postos_sp_rj_gasolina = postos_sp_rj[selecao_2]

#Apenas registros dos estados de SP e RJ com produtos
postos_sp_rj_gasolina

selecao_3 = (postos_sp_rj_gasolina["PREÇO MÉDIO REVENDA"] > 2)
postos_sp_rj_gasolina_preco_maior_que_2 = postos_sp_rj_gasolina[selecao_3]
postos_sp_rj_gasolina_preco_maior_que_2



"""#Selecionando registros dos anos de 2008, 2018 e 2012"""

#Alternativa 1
data.head()

"""#Iterando com DataFrames"""

for index, row in data.head(10).iterrows():
  print(f"indice {index} ==> {row['ESTADO']}")

"""#Preparação de Dados

Tratando observações com valores vazios (null/nan)  no dataset
"""

data

data.info()

"""#Conversão de tipos de atributos

"""

#exemplo, data final e inicial deveriam estar em datatime , preço média de distribuição deveria ser um float, etc

data_pre = data.copy()



"""Datas

"""

data_pre["DATA INICIAL"] = pd.to_datetime(data_pre["DATA INICIAL"], format="%d/%m/%Y")  # Specify the correct format
data_pre["DATA FINAL"] = pd.to_datetime(data_pre["DATA FINAL"], format="%d/%m/%Y")   # Specify the correct format
data_pre.info()

data.info()

"""#Dados Númericos

"""

#converter todos os atributos objetct , para número
#converte a coluna (de valores string) para um tipo numérico
#em casa de erro na conversão (por exemplo, uma string que não representa u número) , u valor vazio (null/ nan)
#será atribuido no lugar
for atributo in  ["MARGEM MÉDIA REVENDA", "DESVIO PADRÃO REVENDA", "PREÇO MÍNIMO REVENDA", "PREÇO MÁXIMO REVENDA"]:
 data_pre[atributo] = pd.to_numeric(data_pre[atributo], errors='coerce')

data_pre.info()

"""#Limpeza de Dados"""

mask = data_pre["PREÇO MÉDIO DISTRIBUIÇÃO"].isnull() # Vai retornar um boolean
data_pre[mask]

#Nos dados originais , quais eram os valores de PREÇO MÉDIO DISTRIBUIÇÃO dos registros que agora possue valores NaN
data[mask]

"""#Podemos preencher os valores Nan com um valor padrão. Para isso, basta usar o método .fillna"""

#Retorna uma cópia do Data Frame "data_pre" com todos os valores Nan de todas as colunas, agora preenchido com 0
#Para alterar o próprio dataFrame,use o argumento inplace =TRUE
data_pre_fill = data_pre.fillna(0)
data_pre_fill

data_pre_fill[mask] #Valores que eram vazios, agora são 0

"""#Removendo todos os valores NaN"""

data_pre.dropna()

data_pre.dropna(inplace=True)

data_pre.info()

"""#Salvando o DataSet Preprocessado"""

data_pre.to_csv("/content/GasPricesInBrazil_2004-2019_preprocessado.csv", index=False, sep = ";")

"""#Estatísticas Descritivas"""

data_final = pd.read_csv("/content/GasPricesInBrazil_2004-2019_preprocessado.csv", sep=';')
data_final.head()

#Método describe
data_final.describe()

data_final.describe()["PREÇO MÉDIO REVENDA"]

#Acessando apenas algumas estatísticas

stats = data_final.describe()
stats

stats.loc[["min", "max", "mean"], ["PREÇO MÉDIO REVENDA", "DESVIO PADRÃO REVENDA"]]



"""Qual preço mínimo revenda?

"""

data_final["PREÇO MÉDIO REVENDA"].min()

"""Qual é a média e desvio padrão dos preços mínimos de revenda?

"""

mean = data_final["PREÇO MÉDIO REVENDA"].mean()
std = data_final["PREÇO MÉDIO REVENDA"].std()
print(f"Média: {mean:2f} | Desvio Padrão: {std:2f}")

"""Quais são os Estados Considerados?"""

data_final["ESTADO"].unique()

#Arrumar os dados
sorted(data_final["ESTADO"].unique()
)

"""Quantos registros (aferiçoes cada estado possui)?"""

data_final["ESTADO"].value_counts() #retorna em ordem decrescente

"""#Executando funções para cada item de um Data Frame ou Series"""

df = pd.DataFrame({ 'A': [1, 2, 3, 4],
                    'B': [10, 20, 30, 40],
                    'C': [100, 200, 300, 400]},
                     index=['Linha 1', 'Linha 2', 'Linha 3', 'Linha 4'])

df

#O APLY() é usado para aplicar uma função ao longo de um eixo de um DataFrame ou em valores em Series

def nossa_soma(linha):
  return linha.sum()    #retorna a soma de todos os valroes de uma linha

df ["SOMA(A , B ,C)"] = df.apply(nossa_soma, axis =1)
df

df.loc["Linha 5"] = df.apply(nossa_soma, axis =0)
df

"""#Usando Lambda Functions"""

df ["Média(A, B, C)"] = df[['A', 'B', "C"]].apply(lambda series: series.mean(), axis =1 )

df

#Aplica a lambda function abaixo para cada elementos da coluna
df ["C*2"] = df["C"].apply(lambda x: x*2)
df



"""#Apply Map"""

df.applymap(lambda x: x**2)

"""map aplica a função em cada elemento"""

nomes = pd.Series(['João', 'Maria', 'Alice', 'Pedro'])
nomes

# retorna uma nova Series com todos os nomes com letras maiuscúlas.
# poderíamos usar uma função ao invés de uma lambda function
nomes.map(lambda x: x.upper())

# O Pandas já fornece uma série de métodos para manipulação de strings.
# Assim, poderíamos usar o código abaixo para obter o mesmo resultado.
nomes.str.upper()

"""#Agrupamento

"""

#Usado para criar grupos de elementos
#Funções podem então ser aplicadas para os elementos de cada grupo, de modo que os resultados de cada grupo são combinados
#groupby
data_final.head()

grupos = data_final.groupby("REGIÃO")
grupos

grupos.groups

grupos.indices

grupos.get_group("NORDESTE")

grupos.describe()

#Também podemos ter agrupamentos por mais de um atributo
grupos_2 = data_final.groupby(["REGIÃO", "ESTADO"])
grupos_2.groups

"""#Quais sãos os preços médios dos Produtos (Combustíveis) para cada Região?"""

grupos = data_final.groupby(["REGIÃO", "PRODUTO"])
grupos

data_final.info()

grupos["PREÇO MÉDIO REVENDA"].mean()

grupos["PREÇO MÉDIO REVENDA"].describe()

#.agg: agrega(roda) uma série de funções para os elementos de um dataframe ou de grupos de um dataframe
df = pd.DataFrame([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9],
                   [None, None, None]],
                  columns=['A', 'B', 'C'])
df

df.agg(['sum', 'min'])  # ignora o vazio

grupos = data_final.groupby(["REGIÃO", "ESTADO"])
grupos["PREÇO MÉDIO REVENDA"].agg(["mean", "std"])

"""#Ordenação"""

notas = pd.DataFrame({
    'nome': ['João', 'Maria', 'José', 'Alice'],
    'idade': [20, 21, 19, 20],
    'nota_final': [5.0, 10.0, 6.0, 10.0]
})
notas

#sort_values : ordena valores ao lonngo de um eixo
notas.sort_values(by="nota_final")

notas.sort_values(by="nota_final", ascending=False)

#Ordenando a partir de mais de uma coluna
notas.sort_values (by = ["nota_final", "nome"], ascending = [False, True])

#Usar o inplace para alterar no dataFrame original
notas.sort_values (by = ["nota_final", "nome"], ascending = [False, True], inplace = True)

notas

"""#Exercícios"""

data_final



#Quantidade de registros de cada produto e cada região?
grupos = df.groupby('PRODUTO')
grupos

grupos['REGIÃO'].value_counts().to_frame()

""" Como os preços da Gasolina Comum em São Paulo variaram em 2018?"""

gasolina_sp_2018 = df.query('PRODUTO == "GASOLINA COMUM" and ESTADO == "SAO PAULO" and ANO == 2018')
gasolina_sp_2018.head()

"""Como os preços da Gasolina Comum e do Etanol em São Paulo variaram em 2018?"""

df.query('(PRODUTO == "GASOLINA COMUM" or PRODUTO == "ETANOL HIDRATADO") and ESTADO == "SAO PAULO")')

